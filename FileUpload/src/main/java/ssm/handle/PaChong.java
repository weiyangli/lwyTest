package ssm.handle;

public class PaChong {
    /*
     * // 线程锁和分布式锁的区别:
     * 如果系统在单机服务器上运行时，直接通过线程锁就可以解决，但是如果线程过多会占用过多的cpu，
     * 对服务器的运行有影响，可以添加线程锁中的互斥锁进行控制，如果有线程占用当前接口，其他线程挂起并不占用cpu，
     * 等待上一个线程结束后，等待的线程会争抢当前线程，抢到的使用(就像一个厕所大家等着上一样)。
     * 分布式锁:它和线程锁的使用场景不同，分布式锁是系统部署在多机系统，但是调用的是一台数据库的数据，都可以操作数据库数据，
     * 这时候就有问题啦，你在操作的时候改变了数据，但是我去拿数据的时候，还是原来的数据，而不是你处理过后的数据，
     * 这个时候就可以用分布式锁啦，可以通过redis存储一个锁的键值，每个服务器的线程都去访问这个键值，当返回未true代表有人在使用，
     * 当返回为false时代表使用结束，其他服务器的线程可以用了。
     * */
    public static void main(String[] args) throws  Exception {

    }

}